## 链接器介绍

<font color=red>链接器</font>是一个将<font color=red>编译器</font>产生的目标文件打包成<font color=red>可执行文件</font>或者<font color=red>库文件</font>或者<font color=red>目标文件</font>的程序

链接器程序的输入是目标文件，输出是可执行文件、库文件或者目标文件

几个概念：源文件，目标文件，可执行文件

- 源文件：用汇编语言或高级语言写出来的代码保存为文件后的结果
- 目标文件经过编译程序产生的能被cpu直接识别二进制文件
- 可执行文件就是将目标文件连接后形成的可执行文件，当然也是二进制的。



#### 链接器可操作的元素

----

链接器可操作的最小元素是一个简单的目标文件，通常我们写的.c源文件编译后就生成了对应的目标文件，我们写的实现文件比如list.c编译后就生成了对应的目标文件list.o(Windows下为list.obj)，这个list.o就是链接器可以操作的最小元素。我们见到的所有应用程序，小到自己实现的hello world程序，大到复杂的比如浏览器，网络服务器等，都是链接器将一个个所需要用到的目标文件汇集起来最终形成了非常复杂的应用程序(Windows下是我们常见的EXE文件，Linux下为ELF文件)。

我们可以把最终的应用程序想象成一座房子，构建房子的最基本的原材料就是砖，房子中各个模块像墙面，地面，屋顶等都是由一块块砖构筑成的。而这里的目标文件就好比构建房子时最基本的砖。房子的各个模块就好比我们是用的静态库，动态库。无论多么复杂庞大的应用程序，对于链接器来说最基本的构建材料都是目标文件。链接器可以将目标文件链接器成为各种库以方便使用，然后链接器将目标文件以及程序依赖的各种库再次链接从而形成最终的可执行文件。




#### 链接器是如何工作的

----

在链接器可操作的元素一节中我们提到，所有的应用程序都是链接器将所需要的一个个简单的目标文件汇集起来形成的。你可以将这个过程想象成拼图游戏，每个拼块就是一个简单的目标文件：

- 拼图游戏当中的每个拼块都依赖于其它拼块提供的拼接口，这就好比我们写的程序模块依赖于其它模块提供的编程接口，比如我们在list.c中实现了一种特定的链表数据结构，其它模块需要使用这种链表，这就是模块间的依赖。而链接器其中一项任务就是要确保提供给链接器进行链接的目标文件集合之间依赖是成立的（也就是说，不会出现在被依赖的模块中链接器找不到需要的接口），这就是后面我们要讲到的符号决议(Symbol Resolution)，开篇提到的第一个问题就来自这个过程。
- 我们在拼图游戏当中通常都是将一整幅图按组成部位一部分一部分拼接好，然后将这些比较完整的大的组成部分拼接成最后一整副图。这就好比链接器会首先将程序每个模块当中目标文件集合链接成库，然后再将各个库进行链接最终形成可执行程序。这就是后面我们要讲到的可执行程序的生成(这也是我们在上一篇文章当中留在本章讨论的)。
- 链接器还有一项任务是无法用这个拼图游戏来类比的，但是这项重要的任务对程序员不可见，作为程序员几乎不会在这个过程遇到问题，这项任务就是重定位。

通过拼图这个游戏的类比，我们给出链接器的工作过程：

- 首先，链接器对给定的目标文件或库的集合进行符号决议以确保模块间的依赖是正确的。
- 其次，链接器将给定的目标文件集合进行拼接打包成需要的库或最终可执行文件。
- 最后，链接器对链接好的库或可执行文件进行重定位。